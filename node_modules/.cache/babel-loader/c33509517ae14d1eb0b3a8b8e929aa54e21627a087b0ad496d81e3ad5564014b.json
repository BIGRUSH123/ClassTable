{"ast":null,"code":"import { isWeekInRanges } from './courseTimeParser';\nexport class SchedulingAlgorithm {\n  constructor(courses, teachers, timeSlots) {\n    this.courses = void 0;\n    this.teachers = void 0;\n    this.timeSlots = void 0;\n    this.schedule = void 0;\n    this.courses = courses;\n    this.teachers = teachers;\n    this.timeSlots = timeSlots.sort((a, b) => a.order - b.order);\n    this.schedule = [];\n  }\n\n  // 主排课方法\n  generateSchedule(options = {}) {\n    this.schedule = [];\n    const conflicts = [];\n    try {\n      // 根据每个课程的固定时间段生成课表\n      for (const course of this.courses) {\n        this.scheduleForCourse(course, options);\n      }\n\n      // 检查冲突\n      const detectedConflicts = this.detectConflicts(options.selectedWeek);\n      conflicts.push(...detectedConflicts);\n      const weekInfo = options.selectedWeek ? `第${options.selectedWeek}周` : options.weekRange ? `第${options.weekRange.start}-${options.weekRange.end}周` : '全学期';\n      return {\n        schedule: this.schedule,\n        conflicts,\n        success: conflicts.length === 0,\n        message: conflicts.length === 0 ? `${weekInfo}课表生成成功！` : `${weekInfo}课表生成完成，但存在 ${conflicts.length} 个时间冲突`\n      };\n    } catch (error) {\n      return {\n        schedule: [],\n        conflicts,\n        success: false,\n        message: `生成失败: ${error instanceof Error ? error.message : '未知错误'}`\n      };\n    }\n  }\n\n  // 为单个课程排课\n  scheduleForCourse(course, options = {}) {\n    // 检查课程是否有固定时间段\n    if (!course.fixedTimeSlots || !Array.isArray(course.fixedTimeSlots)) {\n      console.warn(`课程 ${course.name} 没有有效的固定时间段`);\n      return;\n    }\n\n    // 根据课程的固定时间段生成课表条目\n    for (const fixedSlot of course.fixedTimeSlots) {\n      if (!fixedSlot.timeSlotIds || !Array.isArray(fixedSlot.timeSlotIds)) {\n        console.warn(`课程 ${course.name} 的时间段配置无效`);\n        continue;\n      }\n\n      // 检查该时间段是否在指定的周次范围内\n      if (options.selectedWeek) {\n        if (!isWeekInRanges(options.selectedWeek, fixedSlot.weeks)) {\n          continue; // 跳过不在指定周次的时间段\n        }\n      } else if (options.weekRange) {\n        // 检查时间段的周次是否与指定范围有交集\n        if (fixedSlot.weeks && !this.hasWeekRangeOverlap(fixedSlot.weeks, options.weekRange)) {\n          continue;\n        }\n      }\n      for (const timeSlotId of fixedSlot.timeSlotIds) {\n        const scheduleItem = {\n          id: `${course.id}-${fixedSlot.dayOfWeek}-${timeSlotId}-${this.getWeekSuffix(fixedSlot.weeks, options)}`,\n          courseId: course.id,\n          teacherId: course.teacherId,\n          timeSlotId: timeSlotId,\n          dayOfWeek: fixedSlot.dayOfWeek,\n          weeks: fixedSlot.weeks,\n          location: fixedSlot.location || course.location\n        };\n        this.schedule.push(scheduleItem);\n      }\n    }\n  }\n\n  // 生成周次后缀用于ID\n  getWeekSuffix(weeks, options = {}) {\n    if (options.selectedWeek) {\n      return `w${options.selectedWeek}`;\n    }\n    if (weeks && weeks.length > 0) {\n      return `w${weeks[0].start}-${weeks[0].end}`;\n    }\n    return 'all';\n  }\n\n  // 检查周次范围是否有重叠\n  hasWeekRangeOverlap(timeSlotWeeks, targetRange) {\n    return timeSlotWeeks.some(range => range.start <= targetRange.end && range.end >= targetRange.start);\n  }\n\n  // 检测冲突\n  detectConflicts(selectedWeek) {\n    const conflicts = [];\n\n    // 检查时间冲突 - 同一时间段有多个课程\n    const timeConflicts = this.detectTimeConflicts(selectedWeek);\n    conflicts.push(...timeConflicts);\n    return conflicts;\n  }\n\n  // 检测时间冲突\n  detectTimeConflicts(selectedWeek) {\n    const conflicts = [];\n    const timeMap = new Map();\n\n    // 按时间段分组，考虑周次\n    this.schedule.forEach(item => {\n      // 如果指定了周次，只检查该周次的冲突\n      if (selectedWeek && item.weeks && !isWeekInRanges(selectedWeek, item.weeks)) {\n        return;\n      }\n      const key = `${item.dayOfWeek}-${item.timeSlotId}`;\n      if (!timeMap.has(key)) {\n        timeMap.set(key, []);\n      }\n      timeMap.get(key).push(item);\n    });\n\n    // 检查每个时间段是否有冲突\n    timeMap.forEach((items, timeKey) => {\n      if (items.length > 1) {\n        // 进一步检查周次是否真的重叠\n        const conflictItems = this.findWeekConflictingItems(items, selectedWeek);\n        if (conflictItems.length > 1) {\n          const [dayOfWeek, timeSlotId] = timeKey.split('-');\n          const timeSlot = this.timeSlots.find(ts => ts.id === timeSlotId);\n          const dayName = ['', '周一', '周二', '周三', '周四', '周五', '周六', '周日'][parseInt(dayOfWeek)];\n          const weekInfo = selectedWeek ? `第${selectedWeek}周 ` : '';\n          conflicts.push({\n            type: 'time',\n            message: `${weekInfo}${dayName} ${(timeSlot === null || timeSlot === void 0 ? void 0 : timeSlot.name) || timeSlotId} 有多个课程安排`,\n            items: conflictItems\n          });\n        }\n      }\n    });\n    return conflicts;\n  }\n\n  // 查找在指定周次有冲突的课表项\n  findWeekConflictingItems(items, selectedWeek) {\n    console.log('findWeekConflictingItems 被调用:', {\n      itemsCount: items.length,\n      selectedWeek,\n      items: items.map(item => ({\n        courseId: item.courseId,\n        dayOfWeek: item.dayOfWeek,\n        timeSlotId: item.timeSlotId,\n        weeks: item.weeks\n      }))\n    });\n    if (selectedWeek) {\n      // 如果指定了周次，返回所有在该周次有效的项目\n      const filtered = items.filter(item => !item.weeks || isWeekInRanges(selectedWeek, item.weeks));\n      console.log('指定周次过滤结果:', filtered.length);\n      return filtered;\n    }\n\n    // 如果没有指定周次，检查周次重叠\n    const conflicting = [];\n    for (let i = 0; i < items.length; i++) {\n      const item1 = items[i];\n      let hasConflict = false;\n      for (let j = i + 1; j < items.length; j++) {\n        const item2 = items[j];\n        console.log(`检查冲突: 课程${item1.courseId} vs 课程${item2.courseId}`);\n\n        // 检查两个项目的周次是否有重叠\n        if (this.hasWeekOverlap(item1.weeks, item2.weeks)) {\n          console.log('发现冲突！');\n          hasConflict = true;\n          if (!conflicting.includes(item2)) {\n            conflicting.push(item2);\n          }\n        } else {\n          console.log('无冲突');\n        }\n      }\n      if (hasConflict && !conflicting.includes(item1)) {\n        conflicting.push(item1);\n      }\n    }\n    console.log('findWeekConflictingItems 结果:', {\n      conflictingCount: conflicting.length,\n      originalCount: items.length,\n      returnItems: conflicting.length > 0 ? conflicting.length : items.length\n    });\n\n    // 🚨 这里是关键问题！\n    // 原来的逻辑：如果没有真正的冲突，返回所有项目 (items)\n    // 修正：如果没有真正的冲突，应该返回空数组\n    return conflicting;\n  }\n\n  // 检查两个周次范围是否有重叠\n  hasWeekOverlap(weeks1, weeks2) {\n    // 调试信息\n    console.log('检查周次重叠:', {\n      weeks1,\n      weeks2\n    });\n\n    // 如果其中任何一个没有周次限制，则认为有重叠\n    if (!weeks1 || !weeks2 || weeks1.length === 0 || weeks2.length === 0) {\n      console.log('其中一个没有周次限制，假设重叠');\n      return true;\n    }\n\n    // 检查是否有任何周次范围重叠\n    const hasOverlap = weeks1.some(range1 => weeks2.some(range2 => {\n      const overlap = range1.start <= range2.end && range1.end >= range2.start;\n      console.log(`检查范围: ${range1.start}-${range1.end} vs ${range2.start}-${range2.end}, 重叠: ${overlap}`);\n      return overlap;\n    }));\n    console.log('最终结果:', hasOverlap);\n    return hasOverlap;\n  }\n}","map":{"version":3,"names":["isWeekInRanges","SchedulingAlgorithm","constructor","courses","teachers","timeSlots","schedule","sort","a","b","order","generateSchedule","options","conflicts","course","scheduleForCourse","detectedConflicts","detectConflicts","selectedWeek","push","weekInfo","weekRange","start","end","success","length","message","error","Error","fixedTimeSlots","Array","isArray","console","warn","name","fixedSlot","timeSlotIds","weeks","hasWeekRangeOverlap","timeSlotId","scheduleItem","id","dayOfWeek","getWeekSuffix","courseId","teacherId","location","timeSlotWeeks","targetRange","some","range","timeConflicts","detectTimeConflicts","timeMap","Map","forEach","item","key","has","set","get","items","timeKey","conflictItems","findWeekConflictingItems","split","timeSlot","find","ts","dayName","parseInt","type","log","itemsCount","map","filtered","filter","conflicting","i","item1","hasConflict","j","item2","hasWeekOverlap","includes","conflictingCount","originalCount","returnItems","weeks1","weeks2","hasOverlap","range1","range2","overlap"],"sources":["D:/code/classtable/src/utils/schedulingAlgorithm.ts"],"sourcesContent":["import { \r\n  Course, \r\n  Teacher, \r\n  TimeSlot, \r\n  ScheduleItem, \r\n  Conflict,\r\n  WeekRange \r\n} from '../types';\r\nimport { isWeekInRanges } from './courseTimeParser';\r\n\r\nexport interface SchedulingResult {\r\n  schedule: ScheduleItem[];\r\n  conflicts: Conflict[];\r\n  success: boolean;\r\n  message: string;\r\n}\r\n\r\nexport interface SchedulingOptions {\r\n  selectedWeek?: number; // 指定周次，如果不指定则生成全学期\r\n  weekRange?: { start: number; end: number }; // 周次范围\r\n}\r\n\r\nexport class SchedulingAlgorithm {\r\n  private courses: Course[];\r\n  private teachers: Teacher[];\r\n  private timeSlots: TimeSlot[];\r\n  private schedule: ScheduleItem[];\r\n\r\n  constructor(\r\n    courses: Course[],\r\n    teachers: Teacher[],\r\n    timeSlots: TimeSlot[]\r\n  ) {\r\n    this.courses = courses;\r\n    this.teachers = teachers;\r\n    this.timeSlots = timeSlots.sort((a, b) => a.order - b.order);\r\n    this.schedule = [];\r\n  }\r\n\r\n  // 主排课方法\r\n  public generateSchedule(options: SchedulingOptions = {}): SchedulingResult {\r\n    this.schedule = [];\r\n    const conflicts: Conflict[] = [];\r\n\r\n    try {\r\n      // 根据每个课程的固定时间段生成课表\r\n      for (const course of this.courses) {\r\n        this.scheduleForCourse(course, options);\r\n      }\r\n\r\n      // 检查冲突\r\n      const detectedConflicts = this.detectConflicts(options.selectedWeek);\r\n      conflicts.push(...detectedConflicts);\r\n\r\n      const weekInfo = options.selectedWeek \r\n        ? `第${options.selectedWeek}周` \r\n        : options.weekRange \r\n          ? `第${options.weekRange.start}-${options.weekRange.end}周`\r\n          : '全学期';\r\n\r\n      return {\r\n        schedule: this.schedule,\r\n        conflicts,\r\n        success: conflicts.length === 0,\r\n        message: conflicts.length === 0 \r\n          ? `${weekInfo}课表生成成功！` \r\n          : `${weekInfo}课表生成完成，但存在 ${conflicts.length} 个时间冲突`\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        schedule: [],\r\n        conflicts,\r\n        success: false,\r\n        message: `生成失败: ${error instanceof Error ? error.message : '未知错误'}`\r\n      };\r\n    }\r\n  }\r\n\r\n  // 为单个课程排课\r\n  private scheduleForCourse(course: Course, options: SchedulingOptions = {}): void {\r\n    // 检查课程是否有固定时间段\r\n    if (!course.fixedTimeSlots || !Array.isArray(course.fixedTimeSlots)) {\r\n      console.warn(`课程 ${course.name} 没有有效的固定时间段`);\r\n      return;\r\n    }\r\n\r\n    // 根据课程的固定时间段生成课表条目\r\n    for (const fixedSlot of course.fixedTimeSlots) {\r\n      if (!fixedSlot.timeSlotIds || !Array.isArray(fixedSlot.timeSlotIds)) {\r\n        console.warn(`课程 ${course.name} 的时间段配置无效`);\r\n        continue;\r\n      }\r\n\r\n      // 检查该时间段是否在指定的周次范围内\r\n      if (options.selectedWeek) {\r\n        if (!isWeekInRanges(options.selectedWeek, fixedSlot.weeks)) {\r\n          continue; // 跳过不在指定周次的时间段\r\n        }\r\n      } else if (options.weekRange) {\r\n        // 检查时间段的周次是否与指定范围有交集\r\n        if (fixedSlot.weeks && !this.hasWeekRangeOverlap(fixedSlot.weeks, options.weekRange)) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      for (const timeSlotId of fixedSlot.timeSlotIds) {\r\n        const scheduleItem: ScheduleItem = {\r\n          id: `${course.id}-${fixedSlot.dayOfWeek}-${timeSlotId}-${this.getWeekSuffix(fixedSlot.weeks, options)}`,\r\n          courseId: course.id,\r\n          teacherId: course.teacherId,\r\n          timeSlotId: timeSlotId,\r\n          dayOfWeek: fixedSlot.dayOfWeek,\r\n          weeks: fixedSlot.weeks,\r\n          location: fixedSlot.location || course.location\r\n        };\r\n        \r\n        this.schedule.push(scheduleItem);\r\n      }\r\n    }\r\n  }\r\n\r\n  // 生成周次后缀用于ID\r\n  private getWeekSuffix(weeks?: WeekRange[], options: SchedulingOptions = {}): string {\r\n    if (options.selectedWeek) {\r\n      return `w${options.selectedWeek}`;\r\n    }\r\n    if (weeks && weeks.length > 0) {\r\n      return `w${weeks[0].start}-${weeks[0].end}`;\r\n    }\r\n    return 'all';\r\n  }\r\n\r\n  // 检查周次范围是否有重叠\r\n  private hasWeekRangeOverlap(timeSlotWeeks: WeekRange[], targetRange: { start: number; end: number }): boolean {\r\n    return timeSlotWeeks.some(range => \r\n      range.start <= targetRange.end && range.end >= targetRange.start\r\n    );\r\n  }\r\n\r\n  // 检测冲突\r\n  private detectConflicts(selectedWeek?: number): Conflict[] {\r\n    const conflicts: Conflict[] = [];\r\n\r\n    // 检查时间冲突 - 同一时间段有多个课程\r\n    const timeConflicts = this.detectTimeConflicts(selectedWeek);\r\n    conflicts.push(...timeConflicts);\r\n\r\n    return conflicts;\r\n  }\r\n\r\n  // 检测时间冲突\r\n  private detectTimeConflicts(selectedWeek?: number): Conflict[] {\r\n    const conflicts: Conflict[] = [];\r\n    const timeMap = new Map<string, ScheduleItem[]>();\r\n\r\n    // 按时间段分组，考虑周次\r\n    this.schedule.forEach(item => {\r\n      // 如果指定了周次，只检查该周次的冲突\r\n      if (selectedWeek && item.weeks && !isWeekInRanges(selectedWeek, item.weeks)) {\r\n        return;\r\n      }\r\n\r\n      const key = `${item.dayOfWeek}-${item.timeSlotId}`;\r\n      if (!timeMap.has(key)) {\r\n        timeMap.set(key, []);\r\n      }\r\n      timeMap.get(key)!.push(item);\r\n    });\r\n\r\n    // 检查每个时间段是否有冲突\r\n    timeMap.forEach((items, timeKey) => {\r\n      if (items.length > 1) {\r\n        // 进一步检查周次是否真的重叠\r\n        const conflictItems = this.findWeekConflictingItems(items, selectedWeek);\r\n        \r\n        if (conflictItems.length > 1) {\r\n          const [dayOfWeek, timeSlotId] = timeKey.split('-');\r\n          const timeSlot = this.timeSlots.find(ts => ts.id === timeSlotId);\r\n          const dayName = ['', '周一', '周二', '周三', '周四', '周五', '周六', '周日'][parseInt(dayOfWeek)];\r\n          \r\n          const weekInfo = selectedWeek ? `第${selectedWeek}周 ` : '';\r\n          conflicts.push({\r\n            type: 'time',\r\n            message: `${weekInfo}${dayName} ${timeSlot?.name || timeSlotId} 有多个课程安排`,\r\n            items: conflictItems\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    return conflicts;\r\n  }\r\n\r\n  // 查找在指定周次有冲突的课表项\r\n  private findWeekConflictingItems(items: ScheduleItem[], selectedWeek?: number): ScheduleItem[] {\r\n    console.log('findWeekConflictingItems 被调用:', {\r\n      itemsCount: items.length,\r\n      selectedWeek,\r\n      items: items.map(item => ({\r\n        courseId: item.courseId,\r\n        dayOfWeek: item.dayOfWeek,\r\n        timeSlotId: item.timeSlotId,\r\n        weeks: item.weeks\r\n      }))\r\n    });\r\n\r\n    if (selectedWeek) {\r\n      // 如果指定了周次，返回所有在该周次有效的项目\r\n      const filtered = items.filter(item => !item.weeks || isWeekInRanges(selectedWeek, item.weeks));\r\n      console.log('指定周次过滤结果:', filtered.length);\r\n      return filtered;\r\n    }\r\n\r\n    // 如果没有指定周次，检查周次重叠\r\n    const conflicting: ScheduleItem[] = [];\r\n    \r\n    for (let i = 0; i < items.length; i++) {\r\n      const item1 = items[i];\r\n      let hasConflict = false;\r\n      \r\n      for (let j = i + 1; j < items.length; j++) {\r\n        const item2 = items[j];\r\n        \r\n        console.log(`检查冲突: 课程${item1.courseId} vs 课程${item2.courseId}`);\r\n        \r\n        // 检查两个项目的周次是否有重叠\r\n        if (this.hasWeekOverlap(item1.weeks, item2.weeks)) {\r\n          console.log('发现冲突！');\r\n          hasConflict = true;\r\n          if (!conflicting.includes(item2)) {\r\n            conflicting.push(item2);\r\n          }\r\n        } else {\r\n          console.log('无冲突');\r\n        }\r\n      }\r\n      \r\n      if (hasConflict && !conflicting.includes(item1)) {\r\n        conflicting.push(item1);\r\n      }\r\n    }\r\n    \r\n    console.log('findWeekConflictingItems 结果:', {\r\n      conflictingCount: conflicting.length,\r\n      originalCount: items.length,\r\n      returnItems: conflicting.length > 0 ? conflicting.length : items.length\r\n    });\r\n    \r\n    // 🚨 这里是关键问题！\r\n    // 原来的逻辑：如果没有真正的冲突，返回所有项目 (items)\r\n    // 修正：如果没有真正的冲突，应该返回空数组\r\n    return conflicting;\r\n  }\r\n\r\n  // 检查两个周次范围是否有重叠\r\n  private hasWeekOverlap(weeks1?: WeekRange[], weeks2?: WeekRange[]): boolean {\r\n    // 调试信息\r\n    console.log('检查周次重叠:', {\r\n      weeks1,\r\n      weeks2\r\n    });\r\n    \r\n    // 如果其中任何一个没有周次限制，则认为有重叠\r\n    if (!weeks1 || !weeks2 || weeks1.length === 0 || weeks2.length === 0) {\r\n      console.log('其中一个没有周次限制，假设重叠');\r\n      return true;\r\n    }\r\n\r\n    // 检查是否有任何周次范围重叠\r\n    const hasOverlap = weeks1.some(range1 => \r\n      weeks2.some(range2 => {\r\n        const overlap = range1.start <= range2.end && range1.end >= range2.start;\r\n        console.log(`检查范围: ${range1.start}-${range1.end} vs ${range2.start}-${range2.end}, 重叠: ${overlap}`);\r\n        return overlap;\r\n      })\r\n    );\r\n    \r\n    console.log('最终结果:', hasOverlap);\r\n    return hasOverlap;\r\n  }\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}